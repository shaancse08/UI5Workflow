'use strict';

const jwtDecode = require('jwt-decode');
const requestUtils = require('../utils/request-utils');

module.exports = async function getUserDetails(req, res, next) {
  let userDetails;
  let response;

  if (req.internalUrl && req.internalUrl.route && req.internalUrl.route.service
      && req.internalUrl.route.service === 'sap-approuter-userapi'
      && req.session && req.session.user && req.session.user.token
      && req.session.user.token.accessToken) {
    let endPoint = null;
    if (req.url.includes('currentUser')) {
      endPoint = 'currentUser';
    } else if (req.url.includes('attributes')) {
      endPoint = 'attributes';
    } else {
      return next('Invalid user API endpoint provided');
    }
    let decodedToken = null;
    try {
      decodedToken = jwtDecode(req.session.user.token.accessToken);
    } catch (err) {
      return next('Failed to decode login token ' + err);
    }
    userDetails = {
      firstname: decodedToken.given_name,
      lastname: decodedToken.family_name,
      email: decodedToken.email || decodedToken.name,
      name: decodedToken.user_name || decodedToken.email,
      scopes: decodedToken.scope && decodedToken.scope.toString()
    };
    if (endPoint === 'currentUser') {
      userDetails.displayName = userDetails.firstname && userDetails.lastname ?
      // eslint-disable-next-line max-len
        userDetails.firstname + ' ' + userDetails.lastname + ' (' + userDetails.name + ')'
        : userDetails.name;
      response = JSON.stringify(userDetails, undefined, 2);
      res.setHeader('Cache-Control', 'no-cache, no-store');
      return res.end(response);
    }
    else if (endPoint === 'attributes') {
      try {
        let allProperties = await addCustomProperties(req, userDetails);
        response = JSON.stringify(allProperties, undefined, 2);
        res.setHeader('Cache-Control', 'no-cache, no-store');
        return res.end(response);
      }
      catch (err) {
        next(err);
      }
    }
  } else {
    return next();
  }
};

function addCustomProperties(req, userDetails) {
  return new Promise((resolve, reject) => {
    let responseJSON;
    let serviceXsuaaOptions = getServiceXsuaaOptions(req);

    requestUtils.get(serviceXsuaaOptions, (err, res, body) => {
      if (err || res.statusCode !== 200) {
        req.logger && req.logger.info('Failed to fetch user info by access token ' + (err ? err : res && res.statusCode));
        return resolve(userDetails);
      }
      try {
        responseJSON = JSON.parse(body);
      } catch (e) {
        return reject('Parsing user info ' + body + 'failed ' + e);
      }
      let userAttributes = responseJSON && responseJSON['user_attributes'];
      if (userAttributes) {
        ['aud','nonce','remoteEntityId','zone_uuid','given_name','family_name','email','first_name','last_name','azp','mail'].forEach((prop) => {
          delete userAttributes[prop];
        });
      }
      let userDetailsResponse = {};
      Object.assign(userDetailsResponse, userDetails, userAttributes);
      return resolve(userDetailsResponse);
    });
  });
}

function getServiceXsuaaOptions(req) {
  const accessToken = req.session.user.token && req.session.user.token.accessToken;
  const oauthOptions = req.session.user.token && req.session.user.token.oauthOptions;
  let url;

  oauthOptions.url = !oauthOptions.url.endsWith('/') ? oauthOptions.url + '/' : oauthOptions.url;

  if (oauthOptions.authenticationType === 'xsuaa') {
    url = oauthOptions.url + 'userinfo';
  } else if (oauthOptions.authenticationType === 'ias') {
    url = oauthOptions.url + 'oauth2/userinfo';
  }

  return {
    url: url,
    headers: {
      Authorization: 'Bearer ' + accessToken
    }
  };

}